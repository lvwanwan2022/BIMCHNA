# 渲染抽象层 (Display) 实现原理

**文档位置**: `crates/display/wgpu_render_pipeline.md`
**关联模块**: `kernel` (数据源), `app` (窗口宿主)

## 1. 设计目标
构建一个基于 **WGPU** 的渲染后端，能够同时支持：
1.  **Native 模式**: 在 `winit` 窗口中通过 Vulkan/DX12/Metal 渲染。
2.  **Web 模式**: 编译为 WASM，绑定到 HTML Canvas，通过 WebGL2/WebGPU 渲染。

## 2. 渲染架构 (The Render Graph)

### 2.1 资源管理 (Resource Management)
Display 层维护 GPU 侧的镜像数据，与 Kernel 侧的逻辑数据分离。

*   **MeshManager**: 维护 `wgpu::Buffer` (Vertex/Index buffers)。
    *   *关联实现*: 接收 Kernel 的 `UpdateMesh` 指令，如果 Buffer 空间不足则重新分配，否则通过 `queue.write_buffer` 更新。
*   **MaterialManager**: 维护 `wgpu::BindGroup` 和 Shader Uniforms。
*   **TextureManager**: 维护 `wgpu::Texture`。

### 2.2 渲染管线 (Pipeline)
采用多通道渲染 (Multi-pass Rendering) 结构：

1.  **Shadow Pass** (可选): 生成阴影贴图。
2.  **Geometry Pass**: 绘制不透明物体 (Opaque)。
    *   使用 Depth Buffer 进行深度测试。
3.  **Transparents Pass**: 绘制透明物体。
    *   需要对物体进行排序 (Back-to-Front)。
4.  **UI Overlay Pass** (仅 Native 模式):
    *   如果选择自绘简单 UI（如 Gizmo 坐标轴），在此层绘制。
    *   *注意*: 复杂的业务 UI 由 WebUI 层处理，不在此管线中。
5.  **Post-processing**: 抗锯齿 (FXAA/MSAA)、色调映射 (Tone Mapping)。

## 3. 跨平台适配实现

### 3.1 表面初始化 (Surface Initialization)
```rust
pub async fn init_surface(window: &Window) -> (Surface, Adapter, Device, Queue) {
    let instance = wgpu::Instance::new(...);
    // winit 提供了跨平台的 window handle，wgpu 可以直接利用它创建 Surface
    let surface = unsafe { instance.create_surface(window) }?; 
    // ... Adapter/Device 请求逻辑
}
```

### 3.2 渲染循环 (Render Loop)
*   提供 `render_frame(&mut state)` 函数。
*   **Native**: 在 `winit` 的 `RedrawRequested` 事件中调用。
*   **Web**: 通过 `requestAnimationFrame` 循环调用 (Rust -> WASM -> JS loop)。

## 4. 与 Kernel 的数据同步
为了避免锁竞争，采用**双缓冲**或**命令队列**模式：
1.  Kernel 在 Update 阶段生成 `RenderPacket` (包含变换矩阵数组、指令列表)。
2.  Display 在每一帧开始时消费 `RenderPacket`，更新 GPU 资源。
3.  **落地关键**: 确保 `crates/kernel` 定义的几何数据结构能被高效转换为 `crates/display` 需要的 `Vertex` 格式（如 `[f32; 3]`）。

---
# 文档关系 (Document Relationships)
- **上级 (Parent)**: [[显示引擎.md]]
- **下级 (Children)**: 无
